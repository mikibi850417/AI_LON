'use client';

import { useState } from 'react';
import PortOne from '@portone/browser-sdk/v2';
import {
    Box,
    Paper,
    Typography,
    Select,
    MenuItem,
    FormControl,
    InputLabel,
    Button,
    Alert,
    CircularProgress,
    Dialog,
    DialogTitle,
    DialogContent,
    DialogContentText,
    DialogActions,
} from '@mui/material';

interface PaymentStatus {
    status: 'IDLE' | 'PENDING' | 'PAID' | 'FAILED';
    message?: string;
}

interface SubscriptionPaymentWebhookProps {
    onSuccess?: (orderId: string) => void;
    onError?: (error: string) => void;
    pricePerMonth?: number;
    customerId?: string;
    customerEmail?: string;
    paperStyles?: React.CSSProperties;
    buttonColor?: string;
    buttonHoverColor?: string;
}

export default function SubscriptionPaymentWebhook({
    onSuccess,
    onError,
    pricePerMonth = 9900,
    customerId,
    customerEmail,
    paperStyles = {},
    buttonColor = '#2563eb',
    buttonHoverColor = '#1d4ed8'
}: SubscriptionPaymentWebhookProps) {
    const [months, setMonths] = useState<number>(1);
    const [error, setError] = useState<string | null>(null);
    const [paymentStatus, setPaymentStatus] = useState<PaymentStatus>({
        status: 'IDLE',
    });

    // 랜덤 ID 생성 함수 (quickguide 패턴)
    function randomId() {
        return [...crypto.getRandomValues(new Uint32Array(2))]
            .map((word) => word.toString(16).padStart(8, "0"))
            .join("");
    }

    const handlePayment = async () => {
        if (!customerId) {
            const errorMessage = '로그인이 필요합니다.';
            setError(errorMessage);
            onError?.(errorMessage);
            return;
        }

        setPaymentStatus({ status: 'PENDING' });
        setError(null);

        try {
            // Step 1: Generate a unique payment ID (quickguide pattern)
            const paymentId = randomId();

            // Step 2: Calculate the total amount
            const amount = months * pricePerMonth;

            // Step 3: Request Payment using PortOne V2 API (quickguide pattern)
            const payment = await PortOne.requestPayment({
                storeId: process.env.NEXT_PUBLIC_PORTONE_STORE_ID!,
                channelKey: process.env.NEXT_PUBLIC_PORTONE_CHANNEL_KEY!,
                paymentId: paymentId,
                orderName: `${months}개월 구독`,
                totalAmount: amount,
                currency: "KRW" as const,
                payMethod: "CARD",
                customData: JSON.stringify({
                    user_id: customerId,
                    months: months,
                }),
                customerEmail: customerEmail,
                customerName: '구독자',
            });

            // Step 4: Handle payment response (quickguide pattern)
            if (payment.code !== undefined) {
                // Payment failed or was cancelled
                setPaymentStatus({
                    status: 'FAILED',
                    message: payment.message || '결제에 실패했습니다.',
                });
                onError?.(payment.message || '결제에 실패했습니다.');
                return;
            }

            // Step 5: Verify payment with backend (quickguide pattern)
            // 결제 직후에는 서버에서 결제 정보를 찾지 못할 수도 있으므로 최대 3회 재시도
            let retries = 0;
            const maxRetries = 3;
            const retryInterval = 1500; // 1.5초 간격으로 재시도
            
            const verifyPayment = async (): Promise<boolean> => {
                try {
                    console.log(`결제 확인 시도 중... (${retries + 1}/${maxRetries})`);
                    const completeResponse = await fetch(`${process.env.NEXT_PUBLIC_API_BASE_URL}/api/billing/payment/complete`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            paymentId: payment.paymentId,
                        })
                    });

                    if (!completeResponse.ok) {
                        throw new Error('서버 응답 오류');
                    }
                    
                    const paymentComplete = await completeResponse.json();
                    console.log('결제 확인 응답:', paymentComplete);
                    
                    // 결제가 완료되었다면 성공 처리
                    if (paymentComplete.status === 'PAID') {
                        setPaymentStatus({
                            status: 'PAID',
                        });
                        onSuccess?.(paymentId);
                        return true;
                    } 
                    // 처리 중인 상태라면 재시도
                    else if (paymentComplete.status === 'PENDING') {
                        if (retries < maxRetries - 1) {
                            retries++;
                            console.log(`결제가 아직 처리 중입니다. 재시도 중... (${retries}/${maxRetries})`);
                            await new Promise(resolve => setTimeout(resolve, retryInterval));
                            return await verifyPayment();
                        } else {
                            // 최대 재시도 횟수 초과 시 사용자에게 안내
                            setPaymentStatus({
                                status: 'PAID', // 실제로는 확인 중이지만, 사용자에게는 성공으로 표시
                                message: '결제가 진행 중입니다. 잠시 후 반영될 예정입니다.'
                            });
                            // 여전히 성공 콜백 호출 (실제로 결제는 됐으나 확인이 지연된 것일 가능성이 높음)
                            onSuccess?.(paymentId);
                            return true;
                        }
                    } 
                    // 실패한 경우
                    else {
                        setPaymentStatus({
                            status: 'FAILED',
                            message: paymentComplete.message || '결제 처리 중 오류가 발생했습니다.',
                        });
                        onError?.(paymentComplete.message || '결제 처리 중 오류가 발생했습니다.');
                        return false;
                    }
                } catch (err) {
                    // API 호출 자체 실패 시 재시도
                    if (retries < maxRetries - 1) {
                        retries++;
                        console.log(`결제 확인 요청 실패, 재시도 중... (${retries}/${maxRetries})`);
                        await new Promise(resolve => setTimeout(resolve, retryInterval));
                        return await verifyPayment();
                    } else {
                        const errorMessage = err instanceof Error ? err.message : '서버 연결에 실패했습니다.';
                        setPaymentStatus({
                            status: 'FAILED',
                            message: errorMessage,
                        });
                        onError?.(errorMessage);
                        return false;
                    }
                }
            };
            
            // 결제 검증 시작
            await verifyPayment();

        } catch (err) {
            const errorMessage = err instanceof Error ? err.message : '결제 처리 중 오류가 발생했습니다.';
            setPaymentStatus({
                status: 'FAILED',
                message: errorMessage
            });
            onError?.(errorMessage);
        }
    };

    const isWaitingPayment = paymentStatus.status === 'PENDING';

    // Dialog 닫기 핸들러
    const handleCloseDialog = () => {
        setPaymentStatus({ status: 'IDLE' });
        setError(null);
    };

    return (
        <Box sx={{
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
            minHeight: '100vh',
            backgroundColor: '#f8fafc',
            padding: '24px'
        }}>
            <Paper elevation={3} sx={{
                width: '100%',
                maxWidth: '500px',
                p: 4,
                borderRadius: '16px',
                ...paperStyles
            }}>
                <Typography variant="h4" sx={{ mb: 4, textAlign: 'center', fontWeight: 'bold' }}>
                    구독 결제
                </Typography>

                {error && (
                    <Alert severity="error" sx={{ mb: 3 }}>
                        {error}
                    </Alert>
                )}

                <FormControl fullWidth sx={{ mb: 4 }}>
                    <InputLabel>구독 기간</InputLabel>
                    <Select
                        value={months}
                        label="구독 기간"
                        onChange={(e) => setMonths(Number(e.target.value))}
                        disabled={isWaitingPayment}
                    >
                        <MenuItem value={1}>1개월 ({pricePerMonth.toLocaleString()}원)</MenuItem>
                        <MenuItem value={3}>3개월 ({(pricePerMonth * 3).toLocaleString()}원)</MenuItem>
                        <MenuItem value={6}>6개월 ({(pricePerMonth * 6).toLocaleString()}원)</MenuItem>
                        <MenuItem value={12}>12개월 ({(pricePerMonth * 12).toLocaleString()}원)</MenuItem>
                    </Select>
                </FormControl>

                <Box sx={{
                    backgroundColor: '#f8fafc',
                    p: 3,
                    borderRadius: '8px',
                    mb: 4
                }}>
                    <Typography variant="subtitle1" sx={{ mb: 2 }}>
                        결제 금액
                    </Typography>
                    <Typography variant="h4" sx={{ fontWeight: 'bold', color: buttonColor }}>
                        {(months * pricePerMonth).toLocaleString()}원
                    </Typography>
                </Box>

                <Button
                    fullWidth
                    variant="contained"
                    size="large"
                    onClick={handlePayment}
                    disabled={isWaitingPayment}
                    sx={{
                        py: 2,
                        backgroundColor: buttonColor,
                        '&:hover': {
                            backgroundColor: buttonHoverColor
                        }
                    }}
                >
                    {isWaitingPayment ? (
                        <CircularProgress size={24} sx={{ color: 'white' }} />
                    ) : (
                        '결제하기'
                    )}
                </Button>

                {/* Material UI Dialog for payment result */}
                <Dialog
                    open={paymentStatus.status === 'FAILED' || paymentStatus.status === 'PAID'}
                    onClose={handleCloseDialog}
                    aria-labelledby="payment-dialog-title"
                    aria-describedby="payment-dialog-description"
                >
                    <DialogTitle id="payment-dialog-title">
                        {paymentStatus.status === 'PAID' ? '결제 성공' : '결제 실패'}
                    </DialogTitle>
                    <DialogContent>
                        <DialogContentText id="payment-dialog-description">
                            {paymentStatus.status === 'PAID' && paymentStatus.message 
                                ? paymentStatus.message
                                : paymentStatus.status === 'PAID'
                                ? '결제가 성공적으로 처리되었습니다.'
                                : paymentStatus.message || '결제 처리 중 오류가 발생했습니다.'}
                        </DialogContentText>
                    </DialogContent>
                    <DialogActions>
                        <Button onClick={handleCloseDialog} color="primary" autoFocus>
                            확인
                        </Button>
                    </DialogActions>
                </Dialog>
            </Paper>
        </Box>
    );
}
